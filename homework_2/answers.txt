1. В каких ситуациях применяются типы std::pair и std::tuple?
В случае, если мы хотим хранить объекты разных типов в контейнере. std::pair хранит 2 элемента, std::tuple - сколько
угодно элементов.

2. Когда следует использовать контейнер std::array?
В случае, если на этапе компиляции мы уже знаем размер массива. Его приемуществом является то, что его данные хранятся 
на стэке, поэтому он немного быстрее.

3. Когда следует использовать контейнер std::vector?
В большинстве случаев использование std::vector будет самым разумным, так как данный контейнер предоставляет
динамический массив на куче с амортизированной сложностью добавления элемента в конец О(1) (доступ к элементу по индексу 
тоже О(1)).

4. Когда следует использовать контейнер std::deque?
std::deque позволяет делать быструю вставку элементов в конец и в начало (и удаление). Также он дает доступ к элементу
по индексу за О(1).

5. Когда следует использовать контейнер std::list?
std::list позволяет делать быструю вставку и удаление в любое место контейнера за О(1).

6. Когда следует использовать контейнер std::forward_list?
Дает некоторые преимущества std::list для случаев, когда требуется экономия памяти. Важное ограничение - нельзя итерироваться
в обратном порядке.

7. Какие адаптеры контейнеров есть в стандартной библиотеке?
std::stack, std::queue, std::priority_queue

8. Когда следует использовать контейнер circular buffer из Boost?
Когда нужен контейнер фиксированного размера, который будет хранить последние n значений.

9. Почему контейнер circular buffer из Boost не может войти в стандарт?
Потому что указатель .end() в некоторых случаях может указывать на элемент, стоящий перед тем, на который указывает .begin().

10. Какие типы данных для работы с многомерными массивами вы можете назвать?
std::vector < std::vector <...> >, std::array < std::array <...> >,  std::valarray, boost::multi_array